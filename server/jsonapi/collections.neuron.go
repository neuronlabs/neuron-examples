// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Fri, 28 Aug 2020 20:21:36 +0200

package main

import (
	"context"

	"github.com/neuronlabs/neuron/core"
	"github.com/neuronlabs/neuron/database"
	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
	"github.com/neuronlabs/neuron/query"
	"github.com/neuronlabs/neuron/query/filter"
)

// Neuron_Collections stores all generated collections.
var Neuron_Collections = []core.Initializer{
	NRN_Blogs,
	NRN_Comments,
	NRN_Posts,
}

// NRN_Blogs is the collection used to query Blog model.
var NRN_Blogs = &_Blogs{}

type _Blogs struct {
	Model *mapping.ModelStruct
}

// InitializeCollection implements core.Initializer interface.
func (b *_Blogs) Initialize(_ctrl *core.Controller) error {
	mStruct, err := _ctrl.ModelStruct(&Blog{})
	if err != nil {
		return err
	}
	NRN_Blogs = &_Blogs{Model: mStruct}
	return nil
}

// ToModels converts the input slice of Blog into []mapping.Model
func (b *_Blogs) ToModels(input ...*Blog) []mapping.Model {
	output := make([]mapping.Model, len(input))
	for i := range input {
		output[i] = input[i]
	}
	return output
}

// FromModels converts the input mapping.Model into []*Blog.
func (b *_Blogs) FromModels(input ...mapping.Model) []*Blog {
	output := make([]*Blog, len(input))
	for i := range input {
		output[i] = input[i].(*Blog)
	}
	return output
}

// Query creates the query for the Blog.
func (b *_Blogs) Query(db database.DB, models ...*Blog) *blogsQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.Query(b.Model, queryModels...)
	return &blogsQueryBuilder{builder: builder}
}

// QueryCtx creates the query for the Blog with provided 'ctx' context.
func (b *_Blogs) QueryCtx(ctx context.Context, db database.DB, models ...*Blog) *blogsQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.QueryCtx(ctx, b.Model, queryModels...)
	return &blogsQueryBuilder{builder: builder}
}

// Insert inserts Blog into database.
func (b *_Blogs) Insert(ctx context.Context, db database.DB, models ...*Blog) error {
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Insert(ctx, b.Model, queryModels...)
}

// Update updates Blog models into database.
func (b *_Blogs) Update(ctx context.Context, db database.DB, models ...*Blog) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Update(ctx, b.Model, queryModels...)
}

// Delete deletes Blog models in database.
func (b *_Blogs) Delete(ctx context.Context, db database.DB, models ...*Blog) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Delete(ctx, b.Model, queryModels...)
}

// Refresh creates the query for the Blog with provided 'ctx' context.
func (b *_Blogs) Refresh(ctx context.Context, db database.DB, models ...*Blog) error {
	var queryModels []mapping.Model
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to refresh")
	}
	queryModels = make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Refresh(ctx, b.Model, queryModels...)
}

// AddPosts adds the 'Posts' relationship for provided input 'models'.
func (b *_Blogs) AddPosts(ctx context.Context, db database.DB, model *Blog, relations ...*Post) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationField, err := b.Model.RelationByIndex(3)
	if err != nil {
		return err
	}
	relationModels := make([]mapping.Model, len(relations))
	for i := range relations {
		relationModels[i] = relations[i]
	}
	q := query.NewScope(b.Model, model)
	relationAdder, ok := db.(database.QueryRelationAdder)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationAdder.QueryAddRelations(ctx, q, relationField, relationModels...)
}

// ClearPostsRelation clears the 'Posts' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (b *_Blogs) ClearPostsRelation(ctx context.Context, db database.DB, models ...*Blog) (int64, error) {
	relation, err := b.Model.RelationByIndex(3)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(b.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetPosts gets the 'Posts' relationship for provided input 'model'.
func (b *_Blogs) GetPosts(ctx context.Context, db database.DB, model *Blog, relationFieldset ...string) ([]*Post, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'Blog' primary key value has zero value")
	}
	relationField, err := b.Model.RelationByIndex(3)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'Post'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, b.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return []*Post{}, nil
	}
	result := make([]*Post, len(relations))
	for i, relation := range relations {
		result[i] = relation.(*Post)
	}
	return result, nil
}

// SetPosts sets the 'Posts' relationship for provided input 'models'.
func (b *_Blogs) SetPosts(ctx context.Context, db database.DB, model *Blog, relations ...*Post) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'Blog' primary key value has zero value")
	}
	relationField, err := b.Model.RelationByIndex(3)
	if err != nil {
		return err
	}
	q := query.NewScope(b.Model, model)
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationModels := make([]mapping.Model, len(relations))
	for i, relation := range relations {
		if relation.IsPrimaryKeyZero() {
			return errors.Wrap(mapping.ErrFieldValue, "one of relation 'Posts' model has zero value primary field")
		}
		relationModels[i] = relation
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relationModels...)
}

// ClearTopPostRelation clears the 'TopPost' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (b *_Blogs) ClearTopPostRelation(ctx context.Context, db database.DB, models ...*Blog) (int64, error) {
	relation, err := b.Model.RelationByIndex(4)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(b.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetTopPost gets the 'TopPost' relationship for provided input 'model'.
func (b *_Blogs) GetTopPost(ctx context.Context, db database.DB, model *Blog, relationFieldset ...string) (*Post, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'Blog' primary key value has zero value")
	}
	relationField, err := b.Model.RelationByIndex(4)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'Post'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, b.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return nil, nil
	}
	return relations[0].(*Post), nil
}

// SetTopPost sets the 'TopPost' relationship for provided input 'models'.
func (b *_Blogs) SetTopPost(ctx context.Context, db database.DB, model *Blog, relation *Post) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'Blog' primary key value has zero value")
	}
	relationField, err := b.Model.RelationByIndex(4)
	if err != nil {
		return err
	}
	q := query.NewScope(b.Model, model)
	if relation.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "relation 'TopPost' model has zero value primary field")
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relation)
}

// blogsQueryBuilder is the query builder used to create and execute
// queries for the Blogmodel.
type blogsQueryBuilder struct {
	builder database.Builder
	err     error
}

// Scope returns given query scope.
func (b *blogsQueryBuilder) Scope() *query.Scope {
	return b.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (b *blogsQueryBuilder) Err() error {
	if b.err != nil {
		return b.err
	}
	return b.builder.Err()
}

// Ctx returns the context of given query builder.
func (b *blogsQueryBuilder) Ctx() context.Context {
	return b.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (b *blogsQueryBuilder) Count() (int64, error) {
	if b.err != nil {
		return 0, b.err
	}
	return b.builder.Count()
}

// Insert new 'Blog' instance(s) into the store.
func (b *blogsQueryBuilder) Insert() error {
	if b.err != nil {
		return b.err
	}
	return b.builder.Insert()
}

// Update updates given 'Blog' instances.
func (b *blogsQueryBuilder) Update() (int64, error) {
	if b.err != nil {
		return 0, b.err
	}
	return b.builder.Update()
}

// Find returns all Blog models that matches to given query.
func (b *blogsQueryBuilder) Find() ([]*Blog, error) {
	if b.err != nil {
		return nil, b.err
	}
	queryModels, err := b.builder.Find()
	if err != nil {
		return nil, err
	}
	models := make([]*Blog, len(queryModels))
	for i := range queryModels {
		models[i] = queryModels[i].(*Blog)
	}
	return models, nil
}

// Refresh refreshes input 'Blog' model fields. It might be combine with the included relations.
func (b *blogsQueryBuilder) Refresh() error {
	if b.err != nil {
		return b.err
	}
	return b.builder.Refresh()
}

// Get returns single Blog model that matches given query.
// If the model is not found the function returns error of query.ErrQueryNoResult.
func (b *blogsQueryBuilder) Get() (*Blog, error) {
	if b.err != nil {
		return nil, b.err
	}
	model, err := b.builder.Get()
	if err != nil {
		return nil, err
	}
	return model.(*Blog), nil
}

// Delete deletes Blog instances that matches given query.
func (b *blogsQueryBuilder) Delete() (int64, error) {
	if b.err != nil {
		return 0, b.err
	}
	return b.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (b *blogsQueryBuilder) Filter(filter filter.Filter) *blogsQueryBuilder {
	if b.err != nil {
		return b
	}
	b.builder.Filter(filter)
	return b
}

// Where creates query with given 'filter' and 'values'.
func (b *blogsQueryBuilder) Where(filter string, values ...interface{}) *blogsQueryBuilder {
	if b.err != nil {
		return b
	}
	b.builder.Where(filter, values...)
	return b
}

// IncludePosts includes given 'relation' in the _Blogs query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (b *blogsQueryBuilder) IncludePosts(postsFieldset ...string) *blogsQueryBuilder {
	if b.err != nil {
		return b
	}
	relation, err := NRN_Blogs.Model.RelationByIndex(3)
	if err != nil {
		b.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Posts' by index for model 'Blog' failed: %v", err)
		return b
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range postsFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			b.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'Post' model", field)
			return b
		}
		relationFields = append(relationFields, structField)
	}
	b.builder.Include(relation, relationFields...)
	return b
}

// IncludeTopPost includes given 'relation' in the _Blogs query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (b *blogsQueryBuilder) IncludeTopPost(topPostFieldset ...string) *blogsQueryBuilder {
	if b.err != nil {
		return b
	}
	relation, err := NRN_Blogs.Model.RelationByIndex(4)
	if err != nil {
		b.err = errors.Wrapf(mapping.ErrInternal, "Getting 'TopPost' by index for model 'Blog' failed: %v", err)
		return b
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range topPostFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			b.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'Post' model", field)
			return b
		}
		relationFields = append(relationFields, structField)
	}
	b.builder.Include(relation, relationFields...)
	return b
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (b *blogsQueryBuilder) Limit(limit int64) *blogsQueryBuilder {
	if b.err != nil {
		return b
	}
	b.builder.Limit(limit)
	return b
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (b *blogsQueryBuilder) Offset(offset int64) *blogsQueryBuilder {
	if b.err != nil {
		return b
	}
	b.builder.Offset(offset)
	return b
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - ID / id
//  - CreatedAt / created_at
//  - Title / title
//  - TopPostID / top_post_id
func (b *blogsQueryBuilder) Select(fields ...string) *blogsQueryBuilder {
	if b.err != nil {
		return b
	}
	var fieldSet []*mapping.StructField
	for _, field := range fields {
		structField, ok := NRN_Blogs.Model.FieldByName(field)
		if !ok {
			b.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_Blogs'", field)
			return b
		}
		fieldSet = append(fieldSet, structField)
	}
	b.builder.Select(fieldSet...)
	return b
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - ID
//  - CreatedAt
//  - Title
//  - TopPostID
func (b *blogsQueryBuilder) OrderBy(fields ...string) *blogsQueryBuilder {
	if b.err != nil {
		return b
	}
	sortFields := make([]query.Sort, len(fields))
	for i, field := range fields {
		if len(field) == 0 {
			b.err = errors.Wrap(mapping.ErrInvalidModelField, "cannot set sorting order for an empty field for model: '_Blogs'")
			return b
		}
		var order query.SortOrder
		if field[0] == '-' {
			order = query.DescendingOrder
			field = field[1:]
		}
		structField, ok := NRN_Blogs.Model.FieldByName(field)
		if !ok {
			b.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_Blogs'", field)
			return b
		}
		sortFields[i] = query.SortField{StructField: structField, SortOrder: order}
	}
	b.builder.OrderBy(sortFields...)
	return b
}

// AddPosts adds related model Posts and matches to given Blog.
func (b *blogsQueryBuilder) AddPosts(_posts ...*Post) error {
	if b.err != nil {
		return b.err
	}
	relation, err := NRN_Blogs.Model.RelationByIndex(3)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Posts' relation by index for model 'Blog' failed: %v", err)
	}
	models := make([]mapping.Model, len(_posts))
	for i := range _posts {
		models[i] = _posts[i]
	}
	return b.builder.AddRelations(relation, models...)
}

// AddTopPost adds related model TopPost and matches to given Blog.
func (b *blogsQueryBuilder) AddTopPost(_topPost *Post) error {
	if b.err != nil {
		return b.err
	}
	relation, err := NRN_Blogs.Model.RelationByIndex(4)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'TopPost' relation by index for model 'Blog' failed: %v", err)
	}
	return b.builder.AddRelations(relation, _topPost)
}

// SetPosts sets related model Posts and matches to given Blog.
func (b *blogsQueryBuilder) SetPosts(_posts ...*Post) error {
	if b.err != nil {
		return b.err
	}
	relation, err := NRN_Blogs.Model.RelationByIndex(3)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Posts' relation by index for model 'Blog' failed: %v", err)
	}
	models := make([]mapping.Model, len(_posts))
	for i := range _posts {
		models[i] = _posts[i]
	}
	return b.builder.SetRelations(relation, models...)
}

// SetTopPost sets related model TopPost and matches to given Blog.
func (b *blogsQueryBuilder) SetTopPost(_topPost *Post) error {
	if b.err != nil {
		return b.err
	}
	relation, err := NRN_Blogs.Model.RelationByIndex(4)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'TopPost' relation by index for model 'Blog' failed: %v", err)
	}
	return b.builder.SetRelations(relation, _topPost)
}

// RemovePosts removes related model Posts and matches to given Blog.
func (b *blogsQueryBuilder) RemovePosts() (int64, error) {
	if b.err != nil {
		return 0, b.err
	}
	relation, err := NRN_Blogs.Model.RelationByIndex(3)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Posts' relation by index for model 'Blog' failed: %v", err)
	}
	return b.builder.RemoveRelations(relation)
}

// RemoveTopPost removes related model TopPost and matches to given Blog.
func (b *blogsQueryBuilder) RemoveTopPost() (int64, error) {
	if b.err != nil {
		return 0, b.err
	}
	relation, err := NRN_Blogs.Model.RelationByIndex(4)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'TopPost' relation by index for model 'Blog' failed: %v", err)
	}
	return b.builder.RemoveRelations(relation)
}

// NRN_Comments is the collection used to query Comment model.
var NRN_Comments = &_Comments{}

type _Comments struct {
	Model *mapping.ModelStruct
}

// InitializeCollection implements core.Initializer interface.
func (c *_Comments) Initialize(_ctrl *core.Controller) error {
	mStruct, err := _ctrl.ModelStruct(&Comment{})
	if err != nil {
		return err
	}
	NRN_Comments = &_Comments{Model: mStruct}
	return nil
}

// ToModels converts the input slice of Comment into []mapping.Model
func (c *_Comments) ToModels(input ...*Comment) []mapping.Model {
	output := make([]mapping.Model, len(input))
	for i := range input {
		output[i] = input[i]
	}
	return output
}

// FromModels converts the input mapping.Model into []*Comment.
func (c *_Comments) FromModels(input ...mapping.Model) []*Comment {
	output := make([]*Comment, len(input))
	for i := range input {
		output[i] = input[i].(*Comment)
	}
	return output
}

// Query creates the query for the Comment.
func (c *_Comments) Query(db database.DB, models ...*Comment) *commentsQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.Query(c.Model, queryModels...)
	return &commentsQueryBuilder{builder: builder}
}

// QueryCtx creates the query for the Comment with provided 'ctx' context.
func (c *_Comments) QueryCtx(ctx context.Context, db database.DB, models ...*Comment) *commentsQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.QueryCtx(ctx, c.Model, queryModels...)
	return &commentsQueryBuilder{builder: builder}
}

// Insert inserts Comment into database.
func (c *_Comments) Insert(ctx context.Context, db database.DB, models ...*Comment) error {
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Insert(ctx, c.Model, queryModels...)
}

// Update updates Comment models into database.
func (c *_Comments) Update(ctx context.Context, db database.DB, models ...*Comment) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Update(ctx, c.Model, queryModels...)
}

// Delete deletes Comment models in database.
func (c *_Comments) Delete(ctx context.Context, db database.DB, models ...*Comment) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Delete(ctx, c.Model, queryModels...)
}

// Refresh creates the query for the Comment with provided 'ctx' context.
func (c *_Comments) Refresh(ctx context.Context, db database.DB, models ...*Comment) error {
	var queryModels []mapping.Model
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to refresh")
	}
	queryModels = make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Refresh(ctx, c.Model, queryModels...)
}

// ClearPostRelation clears the 'Post' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (c *_Comments) ClearPostRelation(ctx context.Context, db database.DB, models ...*Comment) (int64, error) {
	relation, err := c.Model.RelationByIndex(2)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(c.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetPost gets the 'Post' relationship for provided input 'model'.
func (c *_Comments) GetPost(ctx context.Context, db database.DB, model *Comment, relationFieldset ...string) (*Post, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'Comment' primary key value has zero value")
	}
	relationField, err := c.Model.RelationByIndex(2)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'Post'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, c.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return nil, nil
	}
	return relations[0].(*Post), nil
}

// SetPost sets the 'Post' relationship for provided input 'models'.
func (c *_Comments) SetPost(ctx context.Context, db database.DB, model *Comment, relation *Post) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'Comment' primary key value has zero value")
	}
	relationField, err := c.Model.RelationByIndex(2)
	if err != nil {
		return err
	}
	q := query.NewScope(c.Model, model)
	if relation.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "relation 'Post' model has zero value primary field")
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relation)
}

// commentsQueryBuilder is the query builder used to create and execute
// queries for the Commentmodel.
type commentsQueryBuilder struct {
	builder database.Builder
	err     error
}

// Scope returns given query scope.
func (c *commentsQueryBuilder) Scope() *query.Scope {
	return c.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (c *commentsQueryBuilder) Err() error {
	if c.err != nil {
		return c.err
	}
	return c.builder.Err()
}

// Ctx returns the context of given query builder.
func (c *commentsQueryBuilder) Ctx() context.Context {
	return c.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (c *commentsQueryBuilder) Count() (int64, error) {
	if c.err != nil {
		return 0, c.err
	}
	return c.builder.Count()
}

// Insert new 'Comment' instance(s) into the store.
func (c *commentsQueryBuilder) Insert() error {
	if c.err != nil {
		return c.err
	}
	return c.builder.Insert()
}

// Update updates given 'Comment' instances.
func (c *commentsQueryBuilder) Update() (int64, error) {
	if c.err != nil {
		return 0, c.err
	}
	return c.builder.Update()
}

// Find returns all Comment models that matches to given query.
func (c *commentsQueryBuilder) Find() ([]*Comment, error) {
	if c.err != nil {
		return nil, c.err
	}
	queryModels, err := c.builder.Find()
	if err != nil {
		return nil, err
	}
	models := make([]*Comment, len(queryModels))
	for i := range queryModels {
		models[i] = queryModels[i].(*Comment)
	}
	return models, nil
}

// Refresh refreshes input 'Comment' model fields. It might be combine with the included relations.
func (c *commentsQueryBuilder) Refresh() error {
	if c.err != nil {
		return c.err
	}
	return c.builder.Refresh()
}

// Get returns single Comment model that matches given query.
// If the model is not found the function returns error of query.ErrQueryNoResult.
func (c *commentsQueryBuilder) Get() (*Comment, error) {
	if c.err != nil {
		return nil, c.err
	}
	model, err := c.builder.Get()
	if err != nil {
		return nil, err
	}
	return model.(*Comment), nil
}

// Delete deletes Comment instances that matches given query.
func (c *commentsQueryBuilder) Delete() (int64, error) {
	if c.err != nil {
		return 0, c.err
	}
	return c.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (c *commentsQueryBuilder) Filter(filter filter.Filter) *commentsQueryBuilder {
	if c.err != nil {
		return c
	}
	c.builder.Filter(filter)
	return c
}

// Where creates query with given 'filter' and 'values'.
func (c *commentsQueryBuilder) Where(filter string, values ...interface{}) *commentsQueryBuilder {
	if c.err != nil {
		return c
	}
	c.builder.Where(filter, values...)
	return c
}

// IncludePost includes given 'relation' in the _Comments query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (c *commentsQueryBuilder) IncludePost(postFieldset ...string) *commentsQueryBuilder {
	if c.err != nil {
		return c
	}
	relation, err := NRN_Comments.Model.RelationByIndex(2)
	if err != nil {
		c.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Post' by index for model 'Comment' failed: %v", err)
		return c
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range postFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			c.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'Post' model", field)
			return c
		}
		relationFields = append(relationFields, structField)
	}
	c.builder.Include(relation, relationFields...)
	return c
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (c *commentsQueryBuilder) Limit(limit int64) *commentsQueryBuilder {
	if c.err != nil {
		return c
	}
	c.builder.Limit(limit)
	return c
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (c *commentsQueryBuilder) Offset(offset int64) *commentsQueryBuilder {
	if c.err != nil {
		return c
	}
	c.builder.Offset(offset)
	return c
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - ID / id
//  - Body / body
//  - PostID / post_id
func (c *commentsQueryBuilder) Select(fields ...string) *commentsQueryBuilder {
	if c.err != nil {
		return c
	}
	var fieldSet []*mapping.StructField
	for _, field := range fields {
		structField, ok := NRN_Comments.Model.FieldByName(field)
		if !ok {
			c.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_Comments'", field)
			return c
		}
		fieldSet = append(fieldSet, structField)
	}
	c.builder.Select(fieldSet...)
	return c
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - ID
//  - Body
//  - PostID
func (c *commentsQueryBuilder) OrderBy(fields ...string) *commentsQueryBuilder {
	if c.err != nil {
		return c
	}
	sortFields := make([]query.Sort, len(fields))
	for i, field := range fields {
		if len(field) == 0 {
			c.err = errors.Wrap(mapping.ErrInvalidModelField, "cannot set sorting order for an empty field for model: '_Comments'")
			return c
		}
		var order query.SortOrder
		if field[0] == '-' {
			order = query.DescendingOrder
			field = field[1:]
		}
		structField, ok := NRN_Comments.Model.FieldByName(field)
		if !ok {
			c.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_Comments'", field)
			return c
		}
		sortFields[i] = query.SortField{StructField: structField, SortOrder: order}
	}
	c.builder.OrderBy(sortFields...)
	return c
}

// AddPost adds related model Post and matches to given Comment.
func (c *commentsQueryBuilder) AddPost(_post *Post) error {
	if c.err != nil {
		return c.err
	}
	relation, err := NRN_Comments.Model.RelationByIndex(2)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Post' relation by index for model 'Comment' failed: %v", err)
	}
	return c.builder.AddRelations(relation, _post)
}

// SetPost sets related model Post and matches to given Comment.
func (c *commentsQueryBuilder) SetPost(_post *Post) error {
	if c.err != nil {
		return c.err
	}
	relation, err := NRN_Comments.Model.RelationByIndex(2)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Post' relation by index for model 'Comment' failed: %v", err)
	}
	return c.builder.SetRelations(relation, _post)
}

// RemovePost removes related model Post and matches to given Comment.
func (c *commentsQueryBuilder) RemovePost() (int64, error) {
	if c.err != nil {
		return 0, c.err
	}
	relation, err := NRN_Comments.Model.RelationByIndex(2)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Post' relation by index for model 'Comment' failed: %v", err)
	}
	return c.builder.RemoveRelations(relation)
}

// NRN_Posts is the collection used to query Post model.
var NRN_Posts = &_Posts{}

type _Posts struct {
	Model *mapping.ModelStruct
}

// InitializeCollection implements core.Initializer interface.
func (p *_Posts) Initialize(_ctrl *core.Controller) error {
	mStruct, err := _ctrl.ModelStruct(&Post{})
	if err != nil {
		return err
	}
	NRN_Posts = &_Posts{Model: mStruct}
	return nil
}

// ToModels converts the input slice of Post into []mapping.Model
func (p *_Posts) ToModels(input ...*Post) []mapping.Model {
	output := make([]mapping.Model, len(input))
	for i := range input {
		output[i] = input[i]
	}
	return output
}

// FromModels converts the input mapping.Model into []*Post.
func (p *_Posts) FromModels(input ...mapping.Model) []*Post {
	output := make([]*Post, len(input))
	for i := range input {
		output[i] = input[i].(*Post)
	}
	return output
}

// Query creates the query for the Post.
func (p *_Posts) Query(db database.DB, models ...*Post) *postsQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.Query(p.Model, queryModels...)
	return &postsQueryBuilder{builder: builder}
}

// QueryCtx creates the query for the Post with provided 'ctx' context.
func (p *_Posts) QueryCtx(ctx context.Context, db database.DB, models ...*Post) *postsQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.QueryCtx(ctx, p.Model, queryModels...)
	return &postsQueryBuilder{builder: builder}
}

// Insert inserts Post into database.
func (p *_Posts) Insert(ctx context.Context, db database.DB, models ...*Post) error {
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Insert(ctx, p.Model, queryModels...)
}

// Update updates Post models into database.
func (p *_Posts) Update(ctx context.Context, db database.DB, models ...*Post) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Update(ctx, p.Model, queryModels...)
}

// Delete deletes Post models in database.
func (p *_Posts) Delete(ctx context.Context, db database.DB, models ...*Post) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Delete(ctx, p.Model, queryModels...)
}

// Refresh creates the query for the Post with provided 'ctx' context.
func (p *_Posts) Refresh(ctx context.Context, db database.DB, models ...*Post) error {
	var queryModels []mapping.Model
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to refresh")
	}
	queryModels = make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Refresh(ctx, p.Model, queryModels...)
}

// ClearBlogRelation clears the 'Blog' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (p *_Posts) ClearBlogRelation(ctx context.Context, db database.DB, models ...*Post) (int64, error) {
	relation, err := p.Model.RelationByIndex(4)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(p.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetBlog gets the 'Blog' relationship for provided input 'model'.
func (p *_Posts) GetBlog(ctx context.Context, db database.DB, model *Post, relationFieldset ...string) (*Blog, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'Post' primary key value has zero value")
	}
	relationField, err := p.Model.RelationByIndex(4)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'Blog'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, p.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return nil, nil
	}
	return relations[0].(*Blog), nil
}

// SetBlog sets the 'Blog' relationship for provided input 'models'.
func (p *_Posts) SetBlog(ctx context.Context, db database.DB, model *Post, relation *Blog) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'Post' primary key value has zero value")
	}
	relationField, err := p.Model.RelationByIndex(4)
	if err != nil {
		return err
	}
	q := query.NewScope(p.Model, model)
	if relation.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "relation 'Blog' model has zero value primary field")
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relation)
}

// AddComments adds the 'Comments' relationship for provided input 'models'.
func (p *_Posts) AddComments(ctx context.Context, db database.DB, model *Post, relations ...*Comment) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationField, err := p.Model.RelationByIndex(6)
	if err != nil {
		return err
	}
	relationModels := make([]mapping.Model, len(relations))
	for i := range relations {
		relationModels[i] = relations[i]
	}
	q := query.NewScope(p.Model, model)
	relationAdder, ok := db.(database.QueryRelationAdder)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationAdder.QueryAddRelations(ctx, q, relationField, relationModels...)
}

// ClearCommentsRelation clears the 'Comments' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (p *_Posts) ClearCommentsRelation(ctx context.Context, db database.DB, models ...*Post) (int64, error) {
	relation, err := p.Model.RelationByIndex(6)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(p.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetComments gets the 'Comments' relationship for provided input 'model'.
func (p *_Posts) GetComments(ctx context.Context, db database.DB, model *Post, relationFieldset ...string) ([]*Comment, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'Post' primary key value has zero value")
	}
	relationField, err := p.Model.RelationByIndex(6)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'Comment'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, p.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return []*Comment{}, nil
	}
	result := make([]*Comment, len(relations))
	for i, relation := range relations {
		result[i] = relation.(*Comment)
	}
	return result, nil
}

// SetComments sets the 'Comments' relationship for provided input 'models'.
func (p *_Posts) SetComments(ctx context.Context, db database.DB, model *Post, relations ...*Comment) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'Post' primary key value has zero value")
	}
	relationField, err := p.Model.RelationByIndex(6)
	if err != nil {
		return err
	}
	q := query.NewScope(p.Model, model)
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationModels := make([]mapping.Model, len(relations))
	for i, relation := range relations {
		if relation.IsPrimaryKeyZero() {
			return errors.Wrap(mapping.ErrFieldValue, "one of relation 'Comments' model has zero value primary field")
		}
		relationModels[i] = relation
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relationModels...)
}

// postsQueryBuilder is the query builder used to create and execute
// queries for the Postmodel.
type postsQueryBuilder struct {
	builder database.Builder
	err     error
}

// Scope returns given query scope.
func (p *postsQueryBuilder) Scope() *query.Scope {
	return p.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (p *postsQueryBuilder) Err() error {
	if p.err != nil {
		return p.err
	}
	return p.builder.Err()
}

// Ctx returns the context of given query builder.
func (p *postsQueryBuilder) Ctx() context.Context {
	return p.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (p *postsQueryBuilder) Count() (int64, error) {
	if p.err != nil {
		return 0, p.err
	}
	return p.builder.Count()
}

// Insert new 'Post' instance(s) into the store.
func (p *postsQueryBuilder) Insert() error {
	if p.err != nil {
		return p.err
	}
	return p.builder.Insert()
}

// Update updates given 'Post' instances.
func (p *postsQueryBuilder) Update() (int64, error) {
	if p.err != nil {
		return 0, p.err
	}
	return p.builder.Update()
}

// Find returns all Post models that matches to given query.
func (p *postsQueryBuilder) Find() ([]*Post, error) {
	if p.err != nil {
		return nil, p.err
	}
	queryModels, err := p.builder.Find()
	if err != nil {
		return nil, err
	}
	models := make([]*Post, len(queryModels))
	for i := range queryModels {
		models[i] = queryModels[i].(*Post)
	}
	return models, nil
}

// Refresh refreshes input 'Post' model fields. It might be combine with the included relations.
func (p *postsQueryBuilder) Refresh() error {
	if p.err != nil {
		return p.err
	}
	return p.builder.Refresh()
}

// Get returns single Post model that matches given query.
// If the model is not found the function returns error of query.ErrQueryNoResult.
func (p *postsQueryBuilder) Get() (*Post, error) {
	if p.err != nil {
		return nil, p.err
	}
	model, err := p.builder.Get()
	if err != nil {
		return nil, err
	}
	return model.(*Post), nil
}

// Delete deletes Post instances that matches given query.
func (p *postsQueryBuilder) Delete() (int64, error) {
	if p.err != nil {
		return 0, p.err
	}
	return p.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (p *postsQueryBuilder) Filter(filter filter.Filter) *postsQueryBuilder {
	if p.err != nil {
		return p
	}
	p.builder.Filter(filter)
	return p
}

// Where creates query with given 'filter' and 'values'.
func (p *postsQueryBuilder) Where(filter string, values ...interface{}) *postsQueryBuilder {
	if p.err != nil {
		return p
	}
	p.builder.Where(filter, values...)
	return p
}

// IncludeBlog includes given 'relation' in the _Posts query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (p *postsQueryBuilder) IncludeBlog(blogFieldset ...string) *postsQueryBuilder {
	if p.err != nil {
		return p
	}
	relation, err := NRN_Posts.Model.RelationByIndex(4)
	if err != nil {
		p.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Blog' by index for model 'Post' failed: %v", err)
		return p
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range blogFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			p.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'Blog' model", field)
			return p
		}
		relationFields = append(relationFields, structField)
	}
	p.builder.Include(relation, relationFields...)
	return p
}

// IncludeComments includes given 'relation' in the _Posts query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (p *postsQueryBuilder) IncludeComments(commentsFieldset ...string) *postsQueryBuilder {
	if p.err != nil {
		return p
	}
	relation, err := NRN_Posts.Model.RelationByIndex(6)
	if err != nil {
		p.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Comments' by index for model 'Post' failed: %v", err)
		return p
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range commentsFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			p.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'Comment' model", field)
			return p
		}
		relationFields = append(relationFields, structField)
	}
	p.builder.Include(relation, relationFields...)
	return p
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (p *postsQueryBuilder) Limit(limit int64) *postsQueryBuilder {
	if p.err != nil {
		return p
	}
	p.builder.Limit(limit)
	return p
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (p *postsQueryBuilder) Offset(offset int64) *postsQueryBuilder {
	if p.err != nil {
		return p
	}
	p.builder.Offset(offset)
	return p
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - ID / id
//  - Title / title
//  - Body / body
//  - Likes / likes
//  - BlogID / blog_id
func (p *postsQueryBuilder) Select(fields ...string) *postsQueryBuilder {
	if p.err != nil {
		return p
	}
	var fieldSet []*mapping.StructField
	for _, field := range fields {
		structField, ok := NRN_Posts.Model.FieldByName(field)
		if !ok {
			p.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_Posts'", field)
			return p
		}
		fieldSet = append(fieldSet, structField)
	}
	p.builder.Select(fieldSet...)
	return p
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - ID
//  - Title
//  - Body
//  - Likes
//  - BlogID
func (p *postsQueryBuilder) OrderBy(fields ...string) *postsQueryBuilder {
	if p.err != nil {
		return p
	}
	sortFields := make([]query.Sort, len(fields))
	for i, field := range fields {
		if len(field) == 0 {
			p.err = errors.Wrap(mapping.ErrInvalidModelField, "cannot set sorting order for an empty field for model: '_Posts'")
			return p
		}
		var order query.SortOrder
		if field[0] == '-' {
			order = query.DescendingOrder
			field = field[1:]
		}
		structField, ok := NRN_Posts.Model.FieldByName(field)
		if !ok {
			p.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_Posts'", field)
			return p
		}
		sortFields[i] = query.SortField{StructField: structField, SortOrder: order}
	}
	p.builder.OrderBy(sortFields...)
	return p
}

// AddBlog adds related model Blog and matches to given Post.
func (p *postsQueryBuilder) AddBlog(_blog *Blog) error {
	if p.err != nil {
		return p.err
	}
	relation, err := NRN_Posts.Model.RelationByIndex(4)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Blog' relation by index for model 'Post' failed: %v", err)
	}
	return p.builder.AddRelations(relation, _blog)
}

// AddComments adds related model Comments and matches to given Post.
func (p *postsQueryBuilder) AddComments(_comments ...*Comment) error {
	if p.err != nil {
		return p.err
	}
	relation, err := NRN_Posts.Model.RelationByIndex(6)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Comments' relation by index for model 'Post' failed: %v", err)
	}
	models := make([]mapping.Model, len(_comments))
	for i := range _comments {
		models[i] = _comments[i]
	}
	return p.builder.AddRelations(relation, models...)
}

// SetBlog sets related model Blog and matches to given Post.
func (p *postsQueryBuilder) SetBlog(_blog *Blog) error {
	if p.err != nil {
		return p.err
	}
	relation, err := NRN_Posts.Model.RelationByIndex(4)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Blog' relation by index for model 'Post' failed: %v", err)
	}
	return p.builder.SetRelations(relation, _blog)
}

// SetComments sets related model Comments and matches to given Post.
func (p *postsQueryBuilder) SetComments(_comments ...*Comment) error {
	if p.err != nil {
		return p.err
	}
	relation, err := NRN_Posts.Model.RelationByIndex(6)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Comments' relation by index for model 'Post' failed: %v", err)
	}
	models := make([]mapping.Model, len(_comments))
	for i := range _comments {
		models[i] = _comments[i]
	}
	return p.builder.SetRelations(relation, models...)
}

// RemoveBlog removes related model Blog and matches to given Post.
func (p *postsQueryBuilder) RemoveBlog() (int64, error) {
	if p.err != nil {
		return 0, p.err
	}
	relation, err := NRN_Posts.Model.RelationByIndex(4)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Blog' relation by index for model 'Post' failed: %v", err)
	}
	return p.builder.RemoveRelations(relation)
}

// RemoveComments removes related model Comments and matches to given Post.
func (p *postsQueryBuilder) RemoveComments() (int64, error) {
	if p.err != nil {
		return 0, p.err
	}
	relation, err := NRN_Posts.Model.RelationByIndex(6)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Comments' relation by index for model 'Post' failed: %v", err)
	}
	return p.builder.RemoveRelations(relation)
}
