// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Fri, 28 Aug 2020 20:21:34 +0200

package main

import (
	"strconv"
	"time"

	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
	"github.com/neuronlabs/neuron/query"
)

// Neuron_Models stores all generated models in this package.
var Neuron_Models = []mapping.Model{
	&Blog{},
	&Comment{},
	&Post{},
}

// Compile time check if Blog implements mapping.Model interface.
var _ mapping.Model = &Blog{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Blog'.
func (b *Blog) NeuronCollectionName() string {
	return "blogs"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (b *Blog) IsPrimaryKeyZero() bool {
	return b.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (b *Blog) GetPrimaryKeyValue() interface{} {
	return b.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (b *Blog) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(b.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (b *Blog) GetPrimaryKeyAddress() interface{} {
	return &b.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (b *Blog) GetPrimaryKeyHashableValue() interface{} {
	return b.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (b *Blog) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (b *Blog) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		b.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		b.ID = int(valueType)
	case int16:
		b.ID = int(valueType)
	case int32:
		b.ID = int(valueType)
	case int64:
		b.ID = int(valueType)
	case uint:
		b.ID = int(valueType)
	case uint8:
		b.ID = int(valueType)
	case uint16:
		b.ID = int(valueType)
	case uint32:
		b.ID = int(valueType)
	case uint64:
		b.ID = int(valueType)
	case float32:
		b.ID = int(valueType)
	case float64:
		b.ID = int(valueType)
	default:
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'Blog'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (b *Blog) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	b.ID = int(tmp)
	return nil
}

// SetFrom implements FromSetter interface.
func (b *Blog) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*Blog)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*b = *from
	return nil
}

// Compile time check if Blog implements mapping.Fielder interface.
var _ mapping.Fielder = &Blog{}

// GetFieldsAddress gets the address of provided 'field'.
func (b *Blog) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &b.ID, nil
	case 1: // CreatedAt
		return &b.CreatedAt, nil
	case 2: // Title
		return &b.Title, nil
	case 5: // TopPostID
		return &b.TopPostID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Blog'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (b *Blog) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // CreatedAt
		return time.Time{}, nil
	case 2: // Title
		return "", nil
	case 5: // TopPostID
		return 0, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (b *Blog) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return b.ID == 0, nil
	case 1: // CreatedAt
		return b.CreatedAt == time.Time{}, nil
	case 2: // Title
		return b.Title == "", nil
	case 5: // TopPostID
		return b.TopPostID == 0, nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (b *Blog) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		b.ID = 0
	case 1: // CreatedAt
		b.CreatedAt = time.Time{}
	case 2: // Title
		b.Title = ""
	case 5: // TopPostID
		b.TopPostID = 0
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (b *Blog) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return b.ID, nil
	case 1: // CreatedAt
		return b.CreatedAt, nil
	case 2: // Title
		return b.Title, nil
	case 5: // TopPostID
		return b.TopPostID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Blog'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (b *Blog) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return b.ID, nil
	case 1: // CreatedAt
		return b.CreatedAt, nil
	case 2: // Title
		return b.Title, nil
	case 5: // TopPostID
		return b.TopPostID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Blog'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (b *Blog) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			b.ID = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			b.ID = 0
			return nil
		}

		switch v := value.(type) {
		case int8:
			b.ID = int(v)
		case int16:
			b.ID = int(v)
		case int32:
			b.ID = int(v)
		case int64:
			b.ID = int(v)
		case uint:
			b.ID = int(v)
		case uint8:
			b.ID = int(v)
		case uint16:
			b.ID = int(v)
		case uint32:
			b.ID = int(v)
		case uint64:
			b.ID = int(v)
		case float32:
			b.ID = int(v)
		case float64:
			b.ID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // CreatedAt
		if v, ok := value.(time.Time); ok {
			b.CreatedAt = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			b.CreatedAt = time.Time{}
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // Title
		if v, ok := value.(string); ok {
			b.Title = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			b.Title = ""
			return nil
		}

		// Check alternate types for the Title.
		if v, ok := value.([]byte); ok {
			b.Title = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 5: // TopPostID
		if v, ok := value.(int); ok {
			b.TopPostID = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			b.TopPostID = 0
			return nil
		}

		switch v := value.(type) {
		case int8:
			b.TopPostID = int(v)
		case int16:
			b.TopPostID = int(v)
		case int32:
			b.TopPostID = int(v)
		case int64:
			b.TopPostID = int(v)
		case uint:
			b.TopPostID = int(v)
		case uint8:
			b.TopPostID = int(v)
		case uint16:
			b.TopPostID = int(v)
		case uint32:
			b.TopPostID = int(v)
		case uint64:
			b.TopPostID = int(v)
		case float32:
			b.TopPostID = int(v)
		case float64:
			b.TopPostID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Blog'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (b *Blog) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // CreatedAt
		temp := b.CreatedAt
		if err := b.CreatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", b.CreatedAt, err)
		}
		bt, err := b.CreatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", b.CreatedAt, err)
		}
		b.CreatedAt = temp
		return string(bt), nil
	case 2: // Title
		return value, nil
	case 5: // TopPostID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Blog'", field.Name())
}

// Compile time check if Blog implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &Blog{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (b *Blog) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 4: // TopPost
		if b.TopPost == nil {
			return nil, nil
		}
		return b.TopPost, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (b *Blog) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 4: // TopPost
		if model == nil {
			b.TopPost = nil
			return nil
		} else if topPost, ok := model.(*Post); ok {
			b.TopPost = topPost
			return nil
		}
		return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid model value: '%T' for relation TopPost", model)
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &Blog{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (b *Blog) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 3: // Posts
		post, ok := model.(*Post)
		if !ok {
			return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Posts'", model)
		}
		b.Posts = append(b.Posts, post)
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'Blog'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (b *Blog) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 3: // Posts
		for _, model := range b.Posts {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (b *Blog) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 3: // Posts
		if index > len(b.Posts)-1 {
			return nil, errors.Wrapf(mapping.ErrInvalidRelationIndex, "index out of possible range. Model: 'Blog', Field Posts")
		}
		return b.Posts[index], nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (b *Blog) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 3: // Posts
		return len(b.Posts), nil
	default:
		return 0, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
}

// SetRelationModels implements mapping.MultiRelationer interface.
func (b *Blog) SetRelationModels(relation *mapping.StructField, models ...mapping.Model) error {
	switch relation.Index[0] {
	case 3: // Posts
		temp := make([]*Post, len(models))
		for i, model := range models {
			post, ok := model.(*Post)
			if !ok {
				return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Posts'", model)
			}
			temp[i] = post
		}
		b.Posts = temp
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'Blog'", relation.String())
	}
	return nil
}

// Compile time check if Comment implements mapping.Model interface.
var _ mapping.Model = &Comment{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Comment'.
func (c *Comment) NeuronCollectionName() string {
	return "comments"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (c *Comment) IsPrimaryKeyZero() bool {
	return c.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (c *Comment) GetPrimaryKeyValue() interface{} {
	return c.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (c *Comment) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(c.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (c *Comment) GetPrimaryKeyAddress() interface{} {
	return &c.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (c *Comment) GetPrimaryKeyHashableValue() interface{} {
	return c.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (c *Comment) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (c *Comment) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		c.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		c.ID = int(valueType)
	case int16:
		c.ID = int(valueType)
	case int32:
		c.ID = int(valueType)
	case int64:
		c.ID = int(valueType)
	case uint:
		c.ID = int(valueType)
	case uint8:
		c.ID = int(valueType)
	case uint16:
		c.ID = int(valueType)
	case uint32:
		c.ID = int(valueType)
	case uint64:
		c.ID = int(valueType)
	case float32:
		c.ID = int(valueType)
	case float64:
		c.ID = int(valueType)
	default:
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'Comment'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (c *Comment) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	c.ID = int(tmp)
	return nil
}

// SetFrom implements FromSetter interface.
func (c *Comment) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*Comment)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*c = *from
	return nil
}

// Compile time check if Comment implements mapping.Fielder interface.
var _ mapping.Fielder = &Comment{}

// GetFieldsAddress gets the address of provided 'field'.
func (c *Comment) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &c.ID, nil
	case 1: // Body
		return &c.Body, nil
	case 3: // PostID
		return &c.PostID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Comment'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (c *Comment) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Body
		return "", nil
	case 3: // PostID
		return nil, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (c *Comment) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID == 0, nil
	case 1: // Body
		return c.Body == "", nil
	case 3: // PostID
		return c.PostID == nil, nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (c *Comment) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		c.ID = 0
	case 1: // Body
		c.Body = ""
	case 3: // PostID
		c.PostID = nil
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (c *Comment) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	case 1: // Body
		return c.Body, nil
	case 3: // PostID
		if c.PostID == nil {
			return nil, nil
		}
		return *c.PostID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Comment'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (c *Comment) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	case 1: // Body
		return c.Body, nil
	case 3: // PostID
		return c.PostID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Comment'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (c *Comment) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			c.ID = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			c.ID = 0
			return nil
		}

		switch v := value.(type) {
		case int8:
			c.ID = int(v)
		case int16:
			c.ID = int(v)
		case int32:
			c.ID = int(v)
		case int64:
			c.ID = int(v)
		case uint:
			c.ID = int(v)
		case uint8:
			c.ID = int(v)
		case uint16:
			c.ID = int(v)
		case uint32:
			c.ID = int(v)
		case uint64:
			c.ID = int(v)
		case float32:
			c.ID = int(v)
		case float64:
			c.ID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Body
		if v, ok := value.(string); ok {
			c.Body = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			c.Body = ""
			return nil
		}

		// Check alternate types for the Body.
		if v, ok := value.([]byte); ok {
			c.Body = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // PostID
		if value == nil {
			c.PostID = nil
			return nil
		}
		if v, ok := value.(*int); ok {
			c.PostID = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(int); ok {
			c.PostID = &v
			return nil
		}

		switch v := value.(type) {
		case int8:
			temp := int(v)
			c.PostID = &temp
		case *int8:
			temp := int(*v)
			c.PostID = &temp
		case int16:
			temp := int(v)
			c.PostID = &temp
		case *int16:
			temp := int(*v)
			c.PostID = &temp
		case int32:
			temp := int(v)
			c.PostID = &temp
		case *int32:
			temp := int(*v)
			c.PostID = &temp
		case int64:
			temp := int(v)
			c.PostID = &temp
		case *int64:
			temp := int(*v)
			c.PostID = &temp
		case uint:
			temp := int(v)
			c.PostID = &temp
		case *uint:
			temp := int(*v)
			c.PostID = &temp
		case uint8:
			temp := int(v)
			c.PostID = &temp
		case *uint8:
			temp := int(*v)
			c.PostID = &temp
		case uint16:
			temp := int(v)
			c.PostID = &temp
		case *uint16:
			temp := int(*v)
			c.PostID = &temp
		case uint32:
			temp := int(v)
			c.PostID = &temp
		case *uint32:
			temp := int(*v)
			c.PostID = &temp
		case uint64:
			temp := int(v)
			c.PostID = &temp
		case *uint64:
			temp := int(*v)
			c.PostID = &temp
		case float32:
			temp := int(v)
			c.PostID = &temp
		case *float32:
			temp := int(*v)
			c.PostID = &temp
		case float64:
			temp := int(v)
			c.PostID = &temp
		case *float64:
			temp := int(*v)
			c.PostID = &temp
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Comment'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (c *Comment) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // Body
		return value, nil
	case 3: // PostID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Comment'", field.Name())
}

// Compile time check if Comment implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &Comment{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (c *Comment) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 2: // Post
		if c.Post == nil {
			return nil, nil
		}
		return c.Post, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, c)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (c *Comment) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 2: // Post
		if model == nil {
			c.Post = nil
			return nil
		} else if post, ok := model.(*Post); ok {
			c.Post = post
			return nil
		}
		return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Post", model)
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, c)
	}
}

// Compile time check if Post implements mapping.Model interface.
var _ mapping.Model = &Post{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Post'.
func (p *Post) NeuronCollectionName() string {
	return "posts"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (p *Post) IsPrimaryKeyZero() bool {
	return p.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (p *Post) GetPrimaryKeyValue() interface{} {
	return p.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (p *Post) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(p.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (p *Post) GetPrimaryKeyAddress() interface{} {
	return &p.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (p *Post) GetPrimaryKeyHashableValue() interface{} {
	return p.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (p *Post) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (p *Post) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		p.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		p.ID = int(valueType)
	case int16:
		p.ID = int(valueType)
	case int32:
		p.ID = int(valueType)
	case int64:
		p.ID = int(valueType)
	case uint:
		p.ID = int(valueType)
	case uint8:
		p.ID = int(valueType)
	case uint16:
		p.ID = int(valueType)
	case uint32:
		p.ID = int(valueType)
	case uint64:
		p.ID = int(valueType)
	case float32:
		p.ID = int(valueType)
	case float64:
		p.ID = int(valueType)
	default:
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'Post'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (p *Post) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	p.ID = int(tmp)
	return nil
}

// SetFrom implements FromSetter interface.
func (p *Post) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*Post)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*p = *from
	return nil
}

// Compile time check if Post implements mapping.Fielder interface.
var _ mapping.Fielder = &Post{}

// GetFieldsAddress gets the address of provided 'field'.
func (p *Post) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &p.ID, nil
	case 1: // Title
		return &p.Title, nil
	case 2: // Body
		return &p.Body, nil
	case 3: // Likes
		return &p.Likes, nil
	case 5: // BlogID
		return &p.BlogID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Post'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (p *Post) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Title
		return "", nil
	case 2: // Body
		return "", nil
	case 3: // Likes
		return 0, nil
	case 5: // BlogID
		return 0, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (p *Post) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID == 0, nil
	case 1: // Title
		return p.Title == "", nil
	case 2: // Body
		return p.Body == "", nil
	case 3: // Likes
		return p.Likes == 0, nil
	case 5: // BlogID
		return p.BlogID == 0, nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (p *Post) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		p.ID = 0
	case 1: // Title
		p.Title = ""
	case 2: // Body
		p.Body = ""
	case 3: // Likes
		p.Likes = 0
	case 5: // BlogID
		p.BlogID = 0
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (p *Post) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID, nil
	case 1: // Title
		return p.Title, nil
	case 2: // Body
		return p.Body, nil
	case 3: // Likes
		return p.Likes, nil
	case 5: // BlogID
		return p.BlogID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Post'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (p *Post) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID, nil
	case 1: // Title
		return p.Title, nil
	case 2: // Body
		return p.Body, nil
	case 3: // Likes
		return p.Likes, nil
	case 5: // BlogID
		return p.BlogID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Post'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (p *Post) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			p.ID = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			p.ID = 0
			return nil
		}

		switch v := value.(type) {
		case int8:
			p.ID = int(v)
		case int16:
			p.ID = int(v)
		case int32:
			p.ID = int(v)
		case int64:
			p.ID = int(v)
		case uint:
			p.ID = int(v)
		case uint8:
			p.ID = int(v)
		case uint16:
			p.ID = int(v)
		case uint32:
			p.ID = int(v)
		case uint64:
			p.ID = int(v)
		case float32:
			p.ID = int(v)
		case float64:
			p.ID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Title
		if v, ok := value.(string); ok {
			p.Title = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			p.Title = ""
			return nil
		}

		// Check alternate types for the Title.
		if v, ok := value.([]byte); ok {
			p.Title = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // Body
		if v, ok := value.(string); ok {
			p.Body = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			p.Body = ""
			return nil
		}

		// Check alternate types for the Body.
		if v, ok := value.([]byte); ok {
			p.Body = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // Likes
		if v, ok := value.(int); ok {
			p.Likes = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			p.Likes = 0
			return nil
		}

		switch v := value.(type) {
		case int8:
			p.Likes = int(v)
		case int16:
			p.Likes = int(v)
		case int32:
			p.Likes = int(v)
		case int64:
			p.Likes = int(v)
		case uint:
			p.Likes = int(v)
		case uint8:
			p.Likes = int(v)
		case uint16:
			p.Likes = int(v)
		case uint32:
			p.Likes = int(v)
		case uint64:
			p.Likes = int(v)
		case float32:
			p.Likes = int(v)
		case float64:
			p.Likes = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 5: // BlogID
		if v, ok := value.(int); ok {
			p.BlogID = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			p.BlogID = 0
			return nil
		}

		switch v := value.(type) {
		case int8:
			p.BlogID = int(v)
		case int16:
			p.BlogID = int(v)
		case int32:
			p.BlogID = int(v)
		case int64:
			p.BlogID = int(v)
		case uint:
			p.BlogID = int(v)
		case uint8:
			p.BlogID = int(v)
		case uint16:
			p.BlogID = int(v)
		case uint32:
			p.BlogID = int(v)
		case uint64:
			p.BlogID = int(v)
		case float32:
			p.BlogID = int(v)
		case float64:
			p.BlogID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Post'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (p *Post) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // Title
		return value, nil
	case 2: // Body
		return value, nil
	case 3: // Likes
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 5: // BlogID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Post'", field.Name())
}

// Compile time check if Post implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &Post{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (p *Post) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 4: // Blog
		if p.Blog == nil {
			return nil, nil
		}
		return p.Blog, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (p *Post) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 4: // Blog
		if model == nil {
			p.Blog = nil
			return nil
		} else if blog, ok := model.(*Blog); ok {
			p.Blog = blog
			return nil
		}
		return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Blog", model)
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &Post{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (p *Post) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 6: // Comments
		comment, ok := model.(*Comment)
		if !ok {
			return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Comments'", model)
		}
		p.Comments = append(p.Comments, comment)
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'Post'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (p *Post) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 6: // Comments
		for _, model := range p.Comments {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (p *Post) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 6: // Comments
		if index > len(p.Comments)-1 {
			return nil, errors.Wrapf(mapping.ErrInvalidRelationIndex, "index out of possible range. Model: 'Post', Field Comments")
		}
		return p.Comments[index], nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (p *Post) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 6: // Comments
		return len(p.Comments), nil
	default:
		return 0, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
}

// SetRelationModels implements mapping.MultiRelationer interface.
func (p *Post) SetRelationModels(relation *mapping.StructField, models ...mapping.Model) error {
	switch relation.Index[0] {
	case 6: // Comments
		temp := make([]*Comment, len(models))
		for i, model := range models {
			comment, ok := model.(*Comment)
			if !ok {
				return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Comments'", model)
			}
			temp[i] = comment
		}
		p.Comments = temp
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'Post'", relation.String())
	}
	return nil
}
